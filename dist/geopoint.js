// Generated by CoffeeScript 1.8.0
var GeoPoint;

GeoPoint = (function() {
  function GeoPoint(lat, lon, rad) {
    if ((typeof rad) === 'undefined') {
      rad = 6371;
    }
    this.setLat(lat);
    this.setLon(lon);
    this._radius = typeof rad === 'number' || rad instanceof Number ? rad : (typeof rad === 'string' && trim(lon) !== '' ? +rad : NaN);
    this;
  }

  GeoPoint.prototype.setLat = function(lat) {
    if (lat != null) {
      return this._lat = (typeof lat) === 'number' || lat instanceof Number ? lat : (typeof lat === 'string' && lat.trim() !== '' ? +lat : NaN);
    }
  };

  GeoPoint.prototype.setLon = function(lon) {
    if (lon != null) {
      return this._lon = (typeof lon) === 'number' || lon instanceof Number ? lon : (typeof lon === 'string' && lon.trim() !== '' ? +lon : NaN);
    }
  };

  GeoPoint.prototype.distanceTo = function(point, precision) {
    var R, a, c, d, dLat, dLon, lat1, lat2, lon1, lon2;
    if (typeof precision === 'undefined') {
      precision = 4;
    }
    R = this._radius;
    lat1 = this._lat.toRad();
    lon1 = this._lon.toRad();
    lat2 = point._lat.toRad();
    lon2 = point._lon.toRad();
    dLat = lat2 - lat1;
    dLon = lon2 - lon1;
    a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    d = R * c;
    return d.toPrecision(precision);
  };

  GeoPoint.prototype.bearingTo = function(point) {
    var brng, dLon, lat1, lat2, x, y;
    lat1 = this._lat.toRad();
    lat2 = point._lat.toRad();
    dLon = (point._lon - this._lon).toRad();
    y = Math.sin(dLon) * Math.cos(lat2);
    x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    brng = Math.atan2(y, x);
    return (brng.toDeg() + 360) % 360;
  };

  GeoPoint.prototype.finalBearingTo = function(point) {
    var brng, dLon, lat1, lat2, x, y;
    lat1 = point._lat.toRad();
    lat2 = this._lat.toRad();
    dLon = (this._lon - point._lon).toRad();
    y = Math.sin(dLon) * Math.cos(lat2);
    x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    brng = Math.atan2(y, x);
    return (brng.toDeg() + 180) % 360;
  };

  GeoPoint.prototype.inPolygon = function(poly) {
    var i, inside, n, p1x, p1y, p2x, p2y, xinters, _i, _ref;
    n = poly.length;
    inside = false;
    p1x = Number(poly[0].lat);
    p1y = Number(poly[0].lon);
    for (i = _i = 0, _ref = poly.length + 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      p2x = Number(poly[i % n].lat);
      p2y = Number(poly[i % n].lon);
      if (this._lat > Math.min(p1y, p2y)) {
        if (this._lat <= Math.max(p1y, p2y)) {
          if (this._lon <= Math.max(p1x, p2x)) {
            if (p1y !== p2y) {
              xinters = (this._lat - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
            }
            if (p1x === p2x || this._lon <= xinters) {
              inside = !inside;
            }
          }
        }
      }
    }
    p1x = p2x;
    p1y = p2y;
    return inside;
  };

  GeoPoint.prototype.midpointTo = function(point) {
    var Bx, By, dLon, lat1, lat2, lat3, lon1, lon3;
    lat1 = this._lat.toRad();
    lon1 = this._lon.toRad();
    lat2 = point._lat.toRad();
    dLon = (point._lon - this._lon).toRad();
    Bx = Math.cos(lat2) * Math.cos(dLon);
    By = Math.cos(lat2) * Math.sin(dLon);
    lat3 = Math.atan2(Math.sin(lat1) + Math.sin(lat2), Math.sqrt((Math.cos(lat1) + Bx) * (Math.cos(lat1) + Bx) + By * By));
    lon3 = lon1 + Math.atan2(By, Math.cos(lat1) + Bx);
    lon3 = (lon3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return new GeoPoint(lat3.toDeg(), lon3.toDeg());
  };

  GeoPoint.prototype.destinationPoint = function(brng, dist) {
    var lat1, lat2, lon1, lon2;
    dist = (typeof dist) === 'number' ? dist : ((typeof dist) === 'string' && dist.trim() !== '' ? +dist : NaN);
    dist = dist / this._radius;
    brng = brng.toRad();
    lat1 = this._lat.toRad();
    lon1 = this._lon.toRad();
    lat2 = Math.asin(Math.sin(lat1) * Math.cos(dist) + Math.cos(lat1) * Math.sin(dist) * Math.cos(brng));
    lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(lat1), Math.cos(dist) - Math.sin(lat1) * Math.sin(lat2));
    lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return new GeoPoint(lat2.toDeg(), lon2.toDeg());
  };

  GeoPoint.prototype.intersection = function(p1, brng1, p2, brng2) {
    var alpha1, alpha2, alpha3, brng12, brng13, brng21, brng23, brngA, brngB, dLat, dLon, dLon13, dist12, dist13, lat1, lat2, lat3, lon1, lon2, lon3;
    brng1 = typeof brng1 === 'number' ? brng1 : (typeof brng1 === 'string' && trim(brng1) !== '' ? +brng1 : NaN);
    brng2 = typeof brng2 === 'number' ? brng2 : (typeof brng2 === 'string' && trim(brng2) !== '' ? +brng2 : NaN);
    lat1 = p1._lat.toRad();
    lon1 = p1._lon.toRad();
    lat2 = p2._lat.toRad();
    lon2 = p2._lon.toRad();
    brng13 = brng1.toRad();
    brng23 = brng2.toRad();
    dLat = lat2 - lat1;
    dLon = lon2 - lon1;
    dist12 = 2 * (Math.asin(Math.sqrt(Math.sin(dLat / 2) * Math.sin(dLat / 2) + (Math.cos(lat1)) * (Math.cos(lat2)) * (Math.sin(dLon / 2)) * (Math.sin(dLon / 2)))));
    if (dist12 === 0) {
      return null;
    }
    brngA = Math.acos((Math.sin(lat2) - Math.sin(lat1) * Math.cos(dist12)) / (Math.sin(dist12) * Math.cos(lat1)));
    if (isNaN(brngA)) {
      brngA = 0;
    }
    brngB = Math.acos((Math.sin(lat1) - Math.sin(lat2) * Math.cos(dist12)) / (Math.sin(dist12) * Math.cos(lat2)));
    if (Math.sin(lon2 - lon1) > 0) {
      brng12 = brngA;
      brng21 = 2 * Math.PI - brngB;
    } else {
      brng12 = 2 * Math.PI - brngA;
      brng21 = brngB;
    }
    alpha1 = (brng13 - brng12 + Math.PI) % (2 * Math.PI) - Math.PI;
    alpha2 = (brng21 - brng23 + Math.PI) % (2 * Math.PI) - Math.PI;
    if ((Math.sinalpha1 === 0 && (Math.sin(alpha2)) === 0) || (Math.sin(alpha1)) * (Math.sin(alpha2)) < 0) {
      return null;
    }
    alpha3 = Math.acos(-Math.cos(alpha1) * Math.cos(alpha2) + Math.sin(alpha1) * Math.sin(alpha2) * Math.cos(dist12));
    dist13 = Math.atan2(Math.sin(dist12) * Math.sin(alpha1) * Math.sin(alpha2), Math.cos(alpha2) + Math.cos(alpha1) * Math.cos(alpha3));
    lat3 = Math.asin(Math.sin(lat1) * Math.cos(dist13) + Math.cos(lat1) * Math.sin(dist13) * Math.cos(brng13));
    dLon13 = Math.atan2(Math.sin(brng13) * Math.sin(dist13) * Math.cos(lat1), Math.cos(dist13) - Math.sin(lat1) * Math.sin(lat3));
    lon3 = lon1 + dLon13;
    lon3 = (lon3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return new GeoPoint(lat3.toDeg(), lon3.toDeg());
  };

  GeoPoint.prototype.rhumbDistanceTo = function(point) {
    var dLat, dLon, dPhi, dist, lat1, lat2, q;
    lat1 = this._lat.toRad();
    lat2 = point._lat.toRad();
    dLat = (point._lat - this._lat).toRad();
    dLon = Math.abs(point._lon - this._lon).toRad();
    dPhi = Math.log(Math.tan(lat2 / 2 + Math.PI / 4) / Math.tan(lat1 / 2 + Math.PI / 4));
    q = !isNaN(dLat / dPhi) ? dLat / dPhi : Math.cos(lat1);
    if (dLon > Math.PI) {
      dLon = 2 * Math.PI - dLon;
    }
    dist = (Math.sqrt(dLat * dLat + q * q * dLon * dLon)) * this._radius;
    return dist.toPrecisionFixed(4);
  };

  GeoPoint.prototype.rhumbBearingTo = function(point) {
    var brng, dLon, dPhi, lat1, lat2;
    lat1 = this._lat.toRad();
    lat2 = this._lat.toRad();
    dLon = (this._lon - this._lon).toRad();
    dPhi = Math.log(Math.tan(lat2 / 2 + Math.PI / 4) / Math.tan(lat1 / 2 + Math.PI / 4));
    if (Math.abs(dLon) > Math.PI) {
      dLon = dLon > 0 ? -(2 * Math.PI - dLon) : 2 * Math.PI + dLon;
    }
    brng = Math.atan2(dLon, dPhi);
    return (brng.toDeg() + 360) % 360;
  };

  GeoPoint.prototype.rhumbDestinationPoint = function(brng, dist) {
    var d, dLat, dLon, dPhi, lat1, lat2, lon1, lon2, q;
    d = parseFloat(dist) / this._radius;
    lat1 = this._lat.toRad();
    lon1 = this._lon.toRad();
    brng = brng.toRad();
    lat2 = lat1 + (d * Math.cos(brng));
    dLat = lat2 - lat1;
    dPhi = (Math.log(Math.tan(lat2 / 2 + Math.PI / 4))) / (Math.tan(lat1 / 2 + Math.PI / 4));
    q = !isNaN(dLat / dPhi) ? dLat / dPhi : Math.cos(lat1);
    dLon = d * (Math.sin(brng)) / q;
    if ((Math.abs(lat2)) > Math.PI / 2) {
      lat2 = lat2 > 0 ? Math.PI - lat2 : -(Math.PI - lat2);
    }
    lon2 = (lon1 + dLon + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return new GeoPoint(lat2.toDeg(), lon2.toDeg());
  };

  GeoPoint.prototype.lat = function(format, dp) {
    if (typeof format === 'undefined') {
      return this._lat;
    }
    return this.toLat(this._lat, format, dp);
  };

  GeoPoint.prototype.lon = function(format, dp) {
    if (typeof format === 'undefined') {
      return this._lon;
    }
    return this.toLon(this._lon, format, dp);
  };

  GeoPoint.prototype.toString = function(format, dp) {
    if (typeof format === 'undefined') {
      format = 'dms';
    }
    if (isNaN(this._lat) || isNaN(this._lon)) {
      return '-,-';
    }
    return "" + (GeoPoint.toLat(this._lat, format, dp)) + "," + (GeoPoint.toLon(this._lon, format, dp));
  };

  return GeoPoint;

})();

GeoPoint.parseDMS = function(dmsStr) {
  var deg, dms;
  if (!(deg instanceof Number) && typeof deg === 'object') {
    throw new TypeError('GeoPoint.parseDMS - dmsStr is [DOM?] object');
  }
  if ((typeof dmsStr) === 'number' && isFinite(dmsStr)) {
    return Number(dmsStr);
  }
  dms = String(dmsStr).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);
  if (dms[dms.length - 1] === '') {
    dms.splice(dms.length - 1);
  }
  if (dms === '') {
    return NaN;
  }
  switch (dms.length) {
    case 3:
      deg = dms[0] / 1 + dms[1] / 60 + dms[2] / 3600;
      break;
    case 2:
      deg = dms[0] / 1 + dms[1] / 60;
      break;
    case 1:
      deg = dms[0];
      break;
    default:
      return NaN;
  }
  if (/^-|[WS]$/i.test(dmsStr.trim())) {
    deg = -deg;
  }
  return Number(deg);
};

GeoPoint.toDMS = function(deg, format, dp) {
  var d, m, min, s, sec;
  if (!(deg instanceof Number) && typeof deg === 'object') {
    throw new TypeError('GeoPoint.toDMS - deg is [DOM?] object');
  }
  if (isNaN(deg)) {
    return NaN;
  }
  if ((typeof format) === 'undefined') {
    format = 'dms';
  }
  if ((typeof dp) === 'undefined') {
    switch (format) {
      case 'd':
        dp = 4;
        break;
      case 'dm':
        dp = 2;
        break;
      case 'dms':
        dp = 0;
        break;
      default:
        format = 'dms';
        dp = 0;
    }
  }
  deg = Math.abs(deg);
  switch (format) {
    case 'd':
      d = deg.toFixed(dp);
      if (d < 100) {
        d = "0" + d;
      }
      if (d < 10) {
        d = "0" + d;
      }
      return "" + d + "\u00B0";
    case 'dm':
      min = (deg * 60).toFixed(dp);
      d = Math.floor(min / 60);
      m = (min % 60).toFixed(dp);
      if (d < 100) {
        d = "0" + d;
      }
      if (d < 10) {
        d = "0" + d;
      }
      if (m < 10) {
        m = "0" + m;
      }
      return "" + d + "\u00B0" + m + "\u2032";
    case 'dms':
      sec = (deg * 3600).toFixed(dp);
      d = Math.floor(sec / 3600);
      m = Math.floor((sec / 60) % 60);
      s = (sec % 60).toFixed(dp);
      if (d < 100) {
        d = "0" + d;
      }
      if (d < 10) {
        d = "0" + d;
      }
      if (m < 10) {
        m = "0" + m;
      }
      if (s < 10) {
        s = "0" + s;
      }
      return "" + d + "\u00B0" + m + "\u2032" + s + "\u2033";
  }
};

GeoPoint.toLat = function(deg, format, dp) {
  var lat;
  lat = GeoPoint.toDMS(deg, format, dp);
  if (!lat || lat === '') {
    return '';
  } else {
    return "" + (lat.slice(1)) + (deg < 0 ? 'S' : 'N');
  }
};

GeoPoint.toLon = function(deg, format, dp) {
  var lon;
  lon = GeoPoint.toDMS(deg, format, dp);
  if (!lon || lon === '') {
    return '';
  } else {
    return "" + lon + (deg < 0 ? 'W' : 'E');
  }
};

GeoPoint.toBrng = function(deg, format, dp) {
  var brng;
  deg = (Number(deg) + 360) % 360;
  brng = GeoPoint.toDMS(deg, format, dp);
  return brng.replace('360', '0');
};

if ((typeof Number.prototype.toRad) === "undefined") {
  Number.prototype.toRad = function() {
    return this * Math.PI / 180;
  };
}

if ((typeof Number.prototype.toDeg) === "undefined") {
  Number.prototype.toDeg = function() {
    return this * 180 / Math.PI;
  };
}

if ((typeof Number.prototype.toPrecisionFixed) === "undefined") {
  Number.prototype.toPrecisionFixed = function(precision) {
    var l, n, numb, scale, sign;
    if (isNaN(this)) {
      return 'NaN';
    }
    numb = this < 0 ? -this : this;
    sign = this < 0 ? '-' : '';
    if (numb === 0) {
      n = '0.';
      while (precision--) {
        n += '0';
      }
      return n;
    }
    scale = Math.ceil(Math.log(numb) * Math.LOG10E);
    n = String(Math.round(numb * Math.pow(10, precision - scale)));
    if (scale > 0) {
      l = scale - n.length;
      while (l-- > 0) {
        n = n + '0';
      }
      if (scale < n.length) {
        n = "" + (n.slice(0, scale)) + "." + (n.slice(scale));
      }
    } else {
      while (scale++ < 0) {
        n = "0" + n;
      }
      n = "0." + n;
    }
    return sign + n;
  };
}

GeoPoint.centroid = function(poly) {
  var coords, x, y, _fn, _i, _len;
  x = 0;
  y = 0;
  _fn = (function(_this) {
    return function(coords) {
      x = x + Number(coords._lon);
      return y = y + Number(coords._lat);
    };
  })(this);
  for (_i = 0, _len = poly.length; _i < _len; _i++) {
    coords = poly[_i];
    _fn(coords);
  }
  return new GeoPoint(y / poly.length, x / poly.length);
};

if ((typeof String.prototype.trim) === "undefined") {
  String.prototype.trim = (function(_this) {
    return function() {
      return String(_this).replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    };
  })(this);
}

if (typeof exports !== "undefined" && exports !== null) {
  module.exports = function(lat, lon) {
    return new GeoPoint(lat, lon);
  };
}
